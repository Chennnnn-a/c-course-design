

华 中 科 技 大 学
《面向对象的程序设计》
上机实验报告









专业班级：自动化1901班			 专业班级：自动化1901班
学    号：U201914566				 学    号：
学生姓名：陈振澔					 学生姓名：段丙坤




一、	实验名称
五子棋
二、	实验需求分析
操作方式：键盘操作
游戏模式：人机对战；双人对战
界面设计：绘制棋盘，包含坐标及棋盘落子点；底部进行提示

三、	实验分工
为了快速高效地完成实验内容，对小组成员进行了必要的分工，促进成员的相互合作和交流，提高工作效率。具体的分工如下：
表1   成员的具体分工
姓  名	任务描述	完成情况
陈振澔	设计五子棋界面和双人对战模式	完成
段丙坤		

四、	概要设计
陈振澔任务部分：
1.预处理
	包含三个整型常量，分别代表数组大小，玩家1棋型，玩家2棋型
2.坐标结构体
		包含两个整型变量，分别代表棋盘行、列，用于二维数组
3.五子棋类
	公有部分：构建游戏框架
函数：游戏初始化：初始化坐标结构体；
				  调用棋盘初始化函数初始化二维数组

开始游戏：根据选择游戏模式函数确定游戏模式；
循环调用不同模式游戏函数；以判断游戏获胜函数
返回值选择结束游戏；根据输入内容选择退出程序
或重新游戏
					  打印棋盘：首先清屏；
循环遍历二维数组，同时根据二维数组内数值分支
选择输出相应棋型、光标或棋盘
玩家操作：定义光标坐标；
循环语句内：获取键值，根据键值选择操作光标
坐标；为坐标对应二维数组元素赋对应值；
打印棋盘

	保护部分：实现游戏不同功能
			函数：棋盘初始化：循环遍历二维数组并赋初值0

				  选择游戏模式：根据键值返回相应数值

				  判断获胜情况：说明：函数仅判断有无获胜，不判断获胜方
								根据当前坐标结构体位置，循环判断行、列、对角
线是否连成5子；根据判断返回相应数值
					  判断获胜方：调用判断获胜情况函数，选择执行：
输出获胜方，返回“true”
无获胜，返回“false”


详细设计
预处理：
const int N = 15;	//棋盘大小15*15
const int flag1 = 1;	//玩家1或电脑标志
const int flag2 = 2;	//玩家2标志

类：
Class GoBang
	{ 
public:	//公有部分
	int _iChessBoard[N][N];		//棋盘数组
			GoBang();	//构造函数
	~GoBang() {};	//析构函数
		void Play(operate & WZQ, GoBang & g)	//游戏
			变量声明：2个Position结构体，分别代表两个玩家落子坐标
					  Int mode;//获取函数ChooseMode()返回值，用于选择模式
			函数调用：ChooseMode()//选择游戏模式，无形参
					  WZQ.centrOprt(1, g)//电脑走，由段丙坤设计
					  PlayChess(player, flag)//玩家走，
										形参：玩家代号，棋型代号
					  	  GetVictory(Play, player, flag)//判断获胜方输出，
形参：坐标结构体，玩家代号，棋型代号

void PrintChessBoard()	//打印棋盘
	算法设计：根据二维数组中元素对应棋型、光标和棋盘格打印棋盘

void PlayChess(Position& pos, int player, char flag)	//玩家走
				变量声明：int X = 8 - 1; int Y = 8 - 1;//定位光标初始位置（8，8）
						  char c;获取键盘键值
	函数调用：system("cls");系统函数，清屏
			  _getch();获取键值
			  PrintChessBoard();打印棋盘
	算法设计：根据获取键值修改X,Y值，并以此定位数组元素；
修改元素值得到对应字符；
限定X,Y范围，防止越界；
判断当前位置数组中是否落子，防止覆盖棋子

protected:	//保护部分
void InitChessBoard()	//棋盘初始化，无形参

int ChooseMode()	//选择游戏模式
	函数调用：system("cls");系统函数，清屏
			  InitChessBoard();//初始化棋盘
	返回值：0退出
			1电脑vs玩家
			2玩家vs玩家
			返回至Play()判断游戏模式

int JudgeVictory(Position pos, int player)	//判断是否存在获胜
	变量声明：int begin = 0;int end = 0;//获取连子起始和结束位置
			  			  int len = 0; int start = 0;int finish = 0;//主对角线连子长度、
起始和结束位置
	算法设计：定位棋子位置和棋型，判断二维数组内行、列、对角线方向
是否5个位置均为相同棋型代号；
			  根据定位棋子位置限制判断方向，防止越界
	返回值：0未下棋
			1存在获胜
			-1和局
			返回至GetVictory(Position& pos, int player, char flag)判断
输出获胜方
bool GetVictory(Position& pos, int player, char flag)	//判断获胜方并输出结果
	函数调用：JudgeVictory(pos, player);判断是否存在获胜
	算法设计：根据形参player确定获胜方并输出结果
			返回值：true 有人获胜
					false 无人获胜
					返回至Play()判断游戏是否继续

private:	//私有部分
vector< int > Array;
			vector< vector<int> > _iChessBoard;	//构建二维动态数组
	}
数据结构：
棋子坐标结构体
typedef struct Position//坐标
{ 
    	int row;	//行
    	int col;	//列
}Position;
表示棋子坐标，用于传递所输入坐标到棋盘数组。


五、	调试与改进
陈振澔任务部分
1.棋子符号"○" "●"为字符串，无法存入字符型数组
修改：将字符型数组改为整型数组，按照符号对应数字选择输出
2.采用输入坐标落子的方法直观性差
	修改：改为根据键值改变数组中数值位置实现移动光标落子
3. LNK2019 无法解析的外部符号
		原因：c语言运行时找不到适当的程序入口函数，一般情况下，如果是windows
程序，那么WinMain是入口函数，例如此处创建的“win32项目”
		修改：右键工程名->“属性”->“预处理器”->预处理定义->点击“<编辑…>”->
“_WINDOWS”改为 “_CONSOLE”->“链接器”->“系统”->“子系统”->
点击切换为“控制台”。确认应用后重新编译。

六、	参考文献
[1]	刘正林编著. 面对对象程序设计(第2版）. 武汉：华中科技大学出版社，2004.
